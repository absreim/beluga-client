import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import { RootState } from "../../redux/store";
import { fetchDocumentAiResults } from "./api";

export interface InvoiceLineItem {
  productCode: string;
  description: string;
  quantity: number | null;
  totalAmount: number | null;
  unitPrice: number | null;
}

export interface InvoiceState {
  lineItems: InvoiceLineItem[] | null;
  status: "idle" | "loading" | "failed";
}

const initialState: InvoiceState = {
  lineItems: null,
  status: "idle",
};

type ExpectedDocumentAiJson = [
  {
    document: {
      entities: [
        {
          type: string;
          properties: [
            {
              type: string;
              mentionText: string;
              normalizedValue: null | {
                text: string;
              };
            }
          ];
        }
      ];
    };
  }
];

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const uploadInvoice = createAsyncThunk(
  "invoice/uploadInvoice",
  async (file: File) => {
    const response = await fetchDocumentAiResults(file);
    // The value we return becomes the `fulfilled` action payload
    const json: ExpectedDocumentAiJson = await response.json();
    return json[0].document.entities
      .filter(({ type }) => type === "line_item")
      .map(({ properties }) => {
        const row: InvoiceLineItem = {
          productCode: "",
          description: "",
          quantity: null,
          totalAmount: null,
          unitPrice: null,
        };
        properties.forEach(({ type, mentionText, normalizedValue }) => {
          switch (type) {
            case "line_item/quantity":
              row.quantity = normalizedValue
                ? Number(normalizedValue.text)
                : null;
              break;
            case "line_item/unit_price":
              row.unitPrice = normalizedValue
                ? Number(normalizedValue.text)
                : null;
              break;
            case "line_item/amount":
              row.totalAmount = normalizedValue
                ? Number(normalizedValue.text)
                : null;
              break;
            case "line_item/product_code":
              row.productCode = mentionText;
              break;
            case "line_item/description":
              row.description = mentionText;
              break;
          }
        });
        return row;
      });
  }
);

export const slice = createSlice({
  name: "invoice",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    deleteRow: (state, action: PayloadAction<number>) => {
      state.lineItems && state.lineItems.splice(action.payload, 1);
    },
    editRow: (
      state,
      action: PayloadAction<{ index: number; item: InvoiceLineItem }>
    ) => {
      state.lineItems &&
        (state.lineItems[action.payload.index] = action.payload.item);
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(uploadInvoice.pending, (state) => {
        state.status = "loading";
      })
      .addCase(uploadInvoice.fulfilled, (state, action) => {
        state.status = "idle";
        state.lineItems = action.payload;
      })
      .addCase(uploadInvoice.rejected, (state) => {
        state.status = "failed";
      });
  },
});

export const { deleteRow, editRow } = slice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectLineItems = (state: RootState) => state.invoice.lineItems;
export const selectLoadingState = (state: RootState) => state.invoice.status;

export default slice.reducer;
