import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import { RootState } from "../../redux/store";
import { fetchDocumentAiResults } from "./api";
import { nanoid } from "nanoid/non-secure";
import { LineItem } from "../../components/LineItemDataGrid.tsx";

export interface InvoiceState {
  lineItems: LineItem[] | null;
  status: "idle" | "loading" | "failed";
}

const initialState: InvoiceState = {
  lineItems: null,
  status: "idle",
};

type ExpectedDocumentAiJson = [
  {
    document: {
      entities: [
        {
          type: string;
          properties: [
            {
              type: string;
              mentionText: string;
              normalizedValue: null | {
                text: string;
              };
            }
          ];
        }
      ];
    };
  }
];

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const uploadInvoice = createAsyncThunk(
  "invoice/uploadInvoice",
  async (file: File) => {
    const response = await fetchDocumentAiResults(file);
    // The value we return becomes the `fulfilled` action payload
    const json: ExpectedDocumentAiJson = await response.json();
    return json[0].document.entities
      .filter(({ type }) => type === "line_item")
      .map(({ properties }) => {
        const row: LineItem = {
          id: nanoid(),
          productCode: "",
          description: "",
          quantity: null,
          totalAmount: null,
          unitPrice: null,
        };
        properties.forEach(({ type, mentionText, normalizedValue }) => {
          switch (type) {
            case "line_item/quantity":
              row.quantity = normalizedValue
                ? Number(normalizedValue.text)
                : null;
              break;
            case "line_item/unit_price":
              row.unitPrice = normalizedValue
                ? Number(normalizedValue.text)
                : null;
              break;
            case "line_item/amount":
              row.totalAmount = normalizedValue
                ? Number(normalizedValue.text)
                : null;
              break;
            case "line_item/product_code":
              row.productCode = mentionText;
              break;
            case "line_item/description":
              row.description = mentionText;
              break;
          }
        });
        return row;
      });
  }
);

export const slice = createSlice({
  name: "invoice",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    addRows: (state, action: PayloadAction<LineItem[]>) => {
      if (state.lineItems) {
        state.lineItems.push(...action.payload);
      }
      else {
        state.lineItems = action.payload
      }
    },
    editRow: (state, action: PayloadAction<LineItem>) => {
      if (!state.lineItems) {
        return
      }
      const foundIndex = state.lineItems.findIndex(
        (item) => item.id === action.payload.id
      );
      if (foundIndex >= 0) {
        state.lineItems[foundIndex] = action.payload;
      }
    },
    deleteRow: (state, action: PayloadAction<string>) => {
      if (!state.lineItems) {
        return
      }
      const foundIndex = state.lineItems.findIndex(
        (item) => item.id === action.payload
      );
      if (foundIndex >= 0) {
        state.lineItems.splice(foundIndex, 1);
      }
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(uploadInvoice.pending, (state) => {
        state.status = "loading";
      })
      .addCase(uploadInvoice.fulfilled, (state, action) => {
        state.status = "idle";
        state.lineItems = action.payload;
      })
      .addCase(uploadInvoice.rejected, (state) => {
        state.status = "failed";
      });
  },
});

export const { addRows, deleteRow, editRow } = slice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectLineItems = (state: RootState) => state.invoice.lineItems;
export const selectLoadingState = (state: RootState) => state.invoice.status;

export default slice.reducer;
